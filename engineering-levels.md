# Engineering levels

## What are they?

We categorise engineers as

* Junior Engineer
* Mid-level Engineer
* Senior Engineer

The name describes how we expect the engineer to be able to contribute when we deliver change to a system.

## Why do we have levels?

1. The levels allow you to plan your career growth. If you aspire to be an engineer at the next level there is a set of capabilities that you need to demonstrate.
2. The levels are defined objectively and measurably so there is no bias to the process. You assess yourself using the same criteria as other engineers.

## What are the capabilities I need to demonstrate?

There's a detailed list for each engineering level. They are mainly intended to assess your _engineering_ capabilities but as you get more senior it's inevitable that there are some other parts of the software development lifecycle that you'll need to be familiar with.

### Categories

The capabilities fall into these categories:

1. Engineering as a professional practice
2. Architecture & design
3. Technologies
4. Writing code
5. Testing & quality assurance
6. Project management & agile practice
7. Product management
8. Operations & infrastructure
9. Technical support
10. Team working and leadership

### Engineering as a professional practice

The areas of engineering that we are interested in are not related to particular tools or languages but to behaviours and disciplines. Good engineers follow good practice in the following areas:

1. Source code management
2. Peer review
3. Churn
4. Technical debt
5. Legacy & professional respect

### Architecture & design

Design is a fundamental part of engineering. You'll never be told exactly how to do something so it's up to you to decide how _you_ will do it. The choices you make, however trivial, should be in line with the principles and practices of good architecture & design.

1. Understanding scope
2. Understanding purpose & business value
3. Assessing multiple approaches
4. API design (internal & external)
5. Understanding key design concepts
    * State & idempotency
    * Concurrency
    * Queues
    * Loose coupling vs tight coupling
6. Design patterns
7. Design validation
8. Design documentation
9. Design change management

### Technologies

1. Choosing technology
2. API types
3. Database types
4. HTTP, HTML & CSS
5. Data flow handling

### Writing code

1. Class & function design
2. Testability
3. Security
4. Code quality
5. Hygiene & atomicity & DRYness

### Testing & quality assurance

1. Understanding the purpose of testing
2. Distinguish between different types of test
3. Testing efficiently

### Project management & agile practice

1. The aims of agile practice
2. Sizing & estimating
3. Prioritisation & conflict resolution
4. Progress & status reporting
5. Agile ceremonies

### Product management

1. Business analysis: use cases & personas
2. Business analysis: functional requirements & user needs
3. User journeys & user experience design
4. Client relationship management

### Operations & infrastructure

1. Release management
2. Deployment
3. Infrastructure as code
4. Livestock not pets
5. Monitoring & alerting

### Technical support

1. Incident management: restoring service
2. Incident management: stakeholder communication
3. Problem management: evidence gathering
4. Problem management: pattern spotting
5. Problem management: root cause analysis

### Team working & leadership

1. Understanding motivation
2. Removing obstacles to progress
3. Creating & communicating vision
4. Dependability & reliability
5. Resolving conflict
6. Organisation design
